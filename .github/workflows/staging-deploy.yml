# .github/workflows/staging-deploy.yml 
# small change for test
name: CD - Staging (Create → Deploy → Test → Destroy)

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, reopened, synchronize, ready_for_review]
  workflow_dispatch: {}

env:
  REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AKS_RG: deakinuni
  AKS_NAME: deakinstellak8s

concurrency:
  group: staging-pr-${{ github.event.number }}
  cancel-in-progress: true

jobs:
  deploy-staging:
    # PR must be from 'testing' in the same repo and into 'main'
    if: >
      github.event_name == 'pull_request' &&
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'testing' &&
      github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Gate: ensure a successful CI (push on 'testing') exists for this PR head SHA
      - name: Ensure CI success for PR head
        id: ensure-ci
        uses: actions/github-script@v7
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'testing',
              event: 'push',
              per_page: 100
            });
            const ok = runs.data.workflow_runs.find(r => r.head_sha === headSha && r.conclusion === 'success');
            if (!ok) core.setFailed(`No successful CI for head SHA ${headSha} on 'testing'.`);
            else core.info(`CI success: run #${ok.id}`);

      - name: Azure Login
        if: steps.ensure-ci.outcome == 'success'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        if: steps.ensure-ci.outcome == 'success'
        run: az aks get-credentials -g "$AKS_RG" -n "$AKS_NAME" --overwrite-existing

      # Use the same tag scheme as CI: testing-<short PR head SHA>
      - name: Compute image TAG from PR head
        if: steps.ensure-ci.outcome == 'success'
        id: meta
        run: |
          SHA="${{ github.event.pull_request.head.sha }}"
          echo "TAG=testing-${SHA::7}" >> "$GITHUB_OUTPUT"
          echo "REG=${{ env.REGISTRY }}" >> "$GITHUB_OUTPUT"

      - name: Show manifest tree (debug)
        if: steps.ensure-ci.outcome == 'success'
        run: |
          echo "Repo tree around k8s/:"
          ls -la
          echo "----- k8s/ -----"
          ls -la k8s || true

      - name: Create / ensure PR staging namespace
        if: steps.ensure-ci.outcome == 'success'
        id: ns
        run: |
          NS="stg-pr-${{ github.event.number }}"
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"
          echo "name=$NS" >> "$GITHUB_OUTPUT"

      # ── Apply manifests from root k8s/ ────────────────────────────────────────
      - name: Apply config & secrets
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f k8s/configmaps.yaml
          kubectl apply -n "$NS" -f k8s/secrets.yaml || true

      - name: Apply databases
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f k8s/product-db.yaml
          kubectl apply -n "$NS" -f k8s/order-db.yaml
          kubectl apply -n "$NS" -f k8s/customer-db.yaml

      - name: Wait for DB deployments
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl rollout status deploy/product-db-deployment-w10e1 -n "$NS" --timeout=300s || true
          kubectl rollout status deploy/order-db-deployment-w10e1   -n "$NS" --timeout=300s || true
          kubectl rollout status deploy/customer-db-deployment-w10e1          -n "$NS" --timeout=300s || true

      - name: Apply services
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f k8s/product-service.yaml
          kubectl apply -n "$NS" -f k8s/order-service.yaml
          kubectl apply -n "$NS" -f k8s/customer-service.yaml
          kubectl apply -n "$NS" -f k8s/frontend.yaml || true

      - name: Set images to PR tag
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          REG="${{ steps.meta.outputs.REG }}"
          TAG="${{ steps.meta.outputs.TAG }}"
          kubectl set image deploy/product-service-w10e1  product-service-container="$REG/product-service:$TAG"   -n "$NS"
          kubectl set image deploy/order-service-w10e1    order-service-container="$REG/order-service:$TAG"       -n "$NS"
          kubectl set image deploy/customer-service-w10e1 customer-service-container="$REG/customer-service:$TAG" -n "$NS"
          kubectl set image deploy/frontend               frontend="$REG/frontend:$TAG"                           -n "$NS" || true
      
      - name: Wait for rollouts
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl rollout status deploy/product-service-w10e1   -n "$NS" --timeout=300s
          kubectl rollout status deploy/order-service-w10e1     -n "$NS" --timeout=300s
          kubectl rollout status deploy/customer-service-w10e1  -n "$NS" --timeout=300s
          kubectl rollout status deploy/frontend                -n "$NS" --timeout=300s || true

      - name: Smoke test (per-service PASS/FAIL summary)
        if: steps.ensure-ci.outcome == 'success'
        run: |
          set -euo pipefail
          NS="${{ steps.ns.outputs.name }}"

          svc_port () { kubectl get svc "$1" -n "$NS" -o jsonpath='{.spec.ports[0].port}'; }

          P_SVC=product-service-w10e1; O_SVC=order-service-w10e1; C_SVC=customer-service-w10e1; F_SVC=frontend-w10e1
          P_PORT=$(svc_port $P_SVC);   O_PORT=$(svc_port $O_SVC);   C_PORT=$(svc_port $C_SVC);   F_PORT=$(svc_port $F_SVC)

          RESULT_PRODUCT=FAIL
          RESULT_ORDER=FAIL
          RESULT_CUSTOMER=FAIL
          RESULT_FRONTEND=FAIL

          try_until_ok() {
            local cmd="$1" max="$2"
            for i in $(seq 1 "$max"); do
              eval "$cmd" && return 0 || sleep 3
            done
            return 1
          }

          echo "→ product /health"
          if try_until_ok "curl -fsS http://$P_SVC:${P_PORT}/health >/dev/null" 20; then RESULT_PRODUCT=PASS; fi

          echo "→ order /health"
          if try_until_ok "curl -fsS http://$O_SVC:${O_PORT}/health >/dev/null" 10; then RESULT_ORDER=PASS; fi

          echo "→ customer /health"
          if try_until_ok "curl -fsS http://$C_SVC:${C_PORT}/health >/dev/null" 10; then RESULT_CUSTOMER=PASS; fi

          echo "→ frontend / (200/301/302)"
          if try_until_ok 'code=$(curl -fsS -o /dev/null -w "%{http_code}" http://'"$F_SVC"':'"$F_PORT"'/ || true); [ "$code" = "200" ] || [ "$code" = "301" ] || [ "$code" = "302" ]' 10; then RESULT_FRONTEND=PASS; fi

          echo "---- SUMMARY ----"
          printf "product:   %s\n" "$RESULT_PRODUCT"
          printf "order:     %s\n" "$RESULT_ORDER"
          printf "customer:  %s\n" "$RESULT_CUSTOMER"
          printf "frontend:  %s\n" "$RESULT_FRONTEND"

          {
            echo "### Staging smoke test"
            echo ""
            echo "| Service | Result |"
            echo "|---|---|"
            echo "| product  | $RESULT_PRODUCT |"
            echo "| order    | $RESULT_ORDER |"
            echo "| customer | $RESULT_CUSTOMER |"
            echo "| frontend | $RESULT_FRONTEND |"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$RESULT_PRODUCT$RESULT_ORDER$RESULT_CUSTOMER$RESULT_FRONTEND" != "PASSPASSPASSPASS" ]; then
            exit 1
          fi

      - name: Destroy staging environment (always)
        if: always()
        run: |
          kubectl delete namespace "${{ steps.ns.outputs.name }}" --wait=false