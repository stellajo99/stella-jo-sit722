name: Staging Deploy & Test

on:
  workflow_run:
    workflows: ["CI (testing push → test → ACR push)"]
    branches: [testing]
    types: [completed]
  workflow_dispatch:

env:
  RESOURCE_GROUP: "rg-staging-${{ github.run_id }}"
  CLUSTER_NAME: "aks-staging-${{ github.run_id }}"
  LOCATION: "australiaeast"
  NAMESPACE: "staging-${{ github.run_id }}"
  REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}

jobs:
  deploy-staging:
    name: Deploy to Staging AKS
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      id-token: write
    outputs:
      resource-group: ${{ env.RESOURCE_GROUP }}
      cluster-name: ${{ env.CLUSTER_NAME }}
      namespace: ${{ env.NAMESPACE }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download deploy manifest
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: deploy-manifest
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Extract image tag
        id: tag
        run: |
          if [ -f "deploy-manifest.json" ]; then
            TAG=$(jq -r '.tag' deploy-manifest.json)
            echo "IMAGE_TAG=$TAG" >> "$GITHUB_OUTPUT"
          else
            echo "IMAGE_TAG=testing-${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"
          fi
          echo "Using image tag: ${{ steps.tag.outputs.IMAGE_TAG }}"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Resource Group
        run: |
          az group create \
            --name ${{ env.RESOURCE_GROUP }} \
            --location ${{ env.LOCATION }} \
            --tags "environment=staging" "cleanup=auto" "run-id=${{ github.run_id }}"

      - name: Create AKS Cluster
        run: |
          az aks create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }} \
            --node-count 2 \
            --node-vm-size Standard_B2s \
            --enable-managed-identity \
            --attach-acr $(echo "${{ env.REGISTRY }}" | cut -d'.' -f1) \
            --generate-ssh-keys \
            --enable-cluster-autoscaler \
            --min-count 1 \
            --max-count 3 \
            --tags "environment=staging" "cleanup=auto" "run-id=${{ github.run_id }}"

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create staging namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }}
          kubectl label namespace ${{ env.NAMESPACE }} environment=staging run-id=${{ github.run_id }}

      - name: Deploy secrets and configmaps
        run: |
          kubectl apply -n ${{ env.NAMESPACE }} -f k8s/secrets.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f k8s/configmaps.yaml

      - name: Deploy databases
        run: |
          kubectl apply -n ${{ env.NAMESPACE }} -f k8s/product-db.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f k8s/order-db.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f k8s/customer-db.yaml

          # Wait for databases to be ready
          kubectl wait --for=condition=ready pod -l app=product-db -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=order-db -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=customer-db -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Deploy services with updated images
        run: |
          # Update image tags in service manifests
          sed "s|deakinstellaregistry.azurecr.io/product_service:v1|${{ env.REGISTRY }}/product-service:${{ steps.tag.outputs.IMAGE_TAG }}|g" k8s/product-service.yaml > product-service-staging.yaml
          sed "s|deakinstellaregistry.azurecr.io/order_service:v1|${{ env.REGISTRY }}/order-service:${{ steps.tag.outputs.IMAGE_TAG }}|g" k8s/order-service.yaml > order-service-staging.yaml
          sed "s|deakinstellaregistry.azurecr.io/customer_service:v1|${{ env.REGISTRY }}/customer-service:${{ steps.tag.outputs.IMAGE_TAG }}|g" k8s/customer-service.yaml > customer-service-staging.yaml

          # Update frontend manifest
          envsubst '${REGISTRY} ${IMAGE_TAG}' < k8s/frontend.yaml > frontend-staging.yaml \
            && export ACR_LOGIN_SERVER="${{ env.REGISTRY }}" IMAGE_TAG="${{ steps.tag.outputs.IMAGE_TAG }}" \
            && envsubst < k8s/frontend.yaml > frontend-staging.yaml

          # Deploy services
          kubectl apply -n ${{ env.NAMESPACE }} -f product-service-staging.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f order-service-staging.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f customer-service-staging.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f frontend-staging.yaml

      - name: Wait for deployments
        run: |
          kubectl wait --for=condition=available deployment/product-service-w10e1 -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/order-service-w10e1 -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/customer-service-w10e1 -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/frontend -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Get service endpoints
        run: |
          echo "Waiting for LoadBalancer services to get external IPs..."
          kubectl get services -n ${{ env.NAMESPACE }}

          # Wait for external IPs (up to 10 minutes)
          timeout 600s bash -c '
            while true; do
              FRONTEND_IP=$(kubectl get service frontend-w10e1 -n ${{ env.NAMESPACE }} -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "")
              if [ -n "$FRONTEND_IP" ] && [ "$FRONTEND_IP" != "null" ]; then
                echo "Frontend available at: http://$FRONTEND_IP"
                echo "FRONTEND_URL=http://$FRONTEND_IP" >> $GITHUB_ENV
                break
              fi
              echo "Waiting for frontend LoadBalancer IP..."
              sleep 30
            done
          ' || echo "LoadBalancer IP not ready within timeout - proceeding with cluster IP testing"

  acceptance-tests:
    name: Run Acceptance Tests
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: always() && needs.deploy-staging.result == 'success'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.deploy-staging.outputs.resource-group }} \
            --name ${{ needs.deploy-staging.outputs.cluster-name }} \
            --overwrite-existing

      - name: Basic health checks
        run: |
          NAMESPACE="${{ needs.deploy-staging.outputs.namespace }}"

          echo "=== Pod Status ==="
          kubectl get pods -n $NAMESPACE

          echo "=== Service Status ==="
          kubectl get services -n $NAMESPACE

          echo "=== Deployment Status ==="
          kubectl get deployments -n $NAMESPACE

          # Check if all pods are running
          echo "=== Checking Pod Health ==="
          kubectl wait --for=condition=ready pod -l app=product-service -n $NAMESPACE --timeout=60s
          kubectl wait --for=condition=ready pod -l app=order-service -n $NAMESPACE --timeout=60s
          kubectl wait --for=condition=ready pod -l app=customer-service -n $NAMESPACE --timeout=60s
          kubectl wait --for=condition=ready pod -l app=frontend -n $NAMESPACE --timeout=60s

          echo "All services are healthy!"

      - name: Service connectivity tests
        run: |
          NAMESPACE="${{ needs.deploy-staging.outputs.namespace }}"

          # Test internal service connectivity
          echo "=== Testing Internal Service Connectivity ==="

          # Port forward to test services
          kubectl port-forward -n $NAMESPACE service/product-service-w10e1 8000:8000 &
          sleep 5

          # Test product service health
          if curl -f http://localhost:8000/health > /dev/null 2>&1; then
            echo "✅ Product service is responsive"
          else
            echo "❌ Product service health check failed"
            exit 1
          fi

          # Kill port forward
          pkill -f "kubectl port-forward" || true

      - name: Manual test notification
        run: |
          NAMESPACE="${{ needs.deploy-staging.outputs.namespace }}"

          echo "=== Staging Environment Ready ==="
          echo "Namespace: $NAMESPACE"
          echo "Frontend URL: ${{ env.FRONTEND_URL || 'Check kubectl get services for LoadBalancer IP' }}"
          echo ""
          echo "For manual testing, you can:"
          echo "1. Get AKS credentials: az aks get-credentials --resource-group ${{ needs.deploy-staging.outputs.resource-group }} --name ${{ needs.deploy-staging.outputs.cluster-name }}"
          echo "2. Check services: kubectl get services -n $NAMESPACE"
          echo "3. Port forward for testing: kubectl port-forward -n $NAMESPACE service/frontend-w10e1 8080:80"
          echo ""
          echo "Environment will be automatically destroyed in the cleanup job."

  cleanup-staging:
    name: Cleanup Staging Environment
    runs-on: ubuntu-latest
    needs: [deploy-staging, acceptance-tests]
    if: always() && needs.deploy-staging.result == 'success'

    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Delete Resource Group
        run: |
          echo "Cleaning up staging environment..."
          az group delete \
            --name ${{ needs.deploy-staging.outputs.resource-group }} \
            --yes \
            --no-wait

          echo "✅ Staging environment cleanup initiated"
          echo "Resource group ${{ needs.deploy-staging.outputs.resource-group }} is being deleted"