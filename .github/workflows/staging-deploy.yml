# .github/workflows/staging-deploy.yml
name: CD - Staging (Create → Deploy → Test → Destroy)

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, reopened, synchronize, ready_for_review]

env:
  REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AKS_RG: deakinuni
  AKS_NAME: deakinstellak8s
  CI_WORKFLOW_NAME: "CI - Stage 1 (testing push → test → ACR push)"  # <- your CI 'name:' exactly

concurrency:
  group: staging-pr-${{ github.event.number }}
  cancel-in-progress: true

jobs:
  deploy-staging:
    # PR source must be 'testing' in the same repo, and base must be 'main'
    if: >
      github.event_name == 'pull_request' &&
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'testing' &&
      github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Gate 2: Ensure the CI (Stage 1) succeeded for this PR head SHA on branch 'testing'
      - name: Ensure CI success for this PR head
        id: ensure-ci
        uses: actions/github-script@v7
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const wfName  = process.env.CI_WORKFLOW_NAME;

            const { data: { workflows } } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner, repo: context.repo.repo
            });
            const ci = workflows.find(wf => wf.name === wfName);
            if (!ci) core.setFailed(`Cannot find CI workflow named: ${wfName}`);

            const { data: { workflow_runs } } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: ci.id,
              branch: 'testing',
              event: 'push',
              per_page: 50
            });

            const ok = workflow_runs.find(r => r.head_sha === headSha && r.conclusion === 'success');
            if (!ok) core.setFailed(`CI not successful for head SHA ${headSha}. Run Stage 1 on 'testing' first.`);
            else core.info(`CI success: run #${ok.id} for ${headSha}`);

      - name: Azure Login
        if: steps.ensure-ci.outcome == 'success'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        if: steps.ensure-ci.outcome == 'success'
        run: az aks get-credentials -g "$AKS_RG" -n "$AKS_NAME" --overwrite-existing

      # Use the same tag scheme as CI: testing-<short PR head SHA>
      - name: Compute image TAG from PR head
        if: steps.ensure-ci.outcome == 'success'
        id: meta
        run: |
          SHA="${{ github.event.pull_request.head.sha }}"
          echo "TAG=testing-${SHA::7}" >> "$GITHUB_OUTPUT"
          echo "REG=${{ env.REGISTRY }}" >> "$GITHUB_OUTPUT"

      - name: Create / ensure PR staging namespace
        if: steps.ensure-ci.outcome == 'success'
        id: ns
        run: |
          NS="stg-pr-${{ github.event.number }}"
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"
          echo "name=$NS" >> "$GITHUB_OUTPUT"

      - name: Apply config & secrets
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f week10/k8s/configmaps.yaml
          kubectl apply -n "$NS" -f week10/k8s/secrets.yaml || true

      - name: Apply databases
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f week10/k8s/product-db.yaml
          kubectl apply -n "$NS" -f week10/k8s/order-db.yaml
          kubectl apply -n "$NS" -f week10/k8s/customer-db.yaml

      - name: Apply services
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f week10/k8s/product-service.yaml
          kubectl apply -n "$NS" -f week10/k8s/order-service.yaml
          kubectl apply -n "$NS" -f week10/k8s/customer-service.yaml
          kubectl apply -n "$NS" -f week10/k8s/frontend.yaml || true

      - name: Set container images to new tag
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          REG="${{ steps.meta.outputs.REG }}"
          TAG="${{ steps.meta.outputs.TAG }}"
          kubectl set image deploy/product-service-w10e1   product-service-container="$REG/product-service:$TAG"   -n "$NS"
          kubectl set image deploy/order-service-w10e1     order-service-container="$REG/order-service:$TAG"       -n "$NS"
          kubectl set image deploy/customer-service-w10e1  customer-service-container="$REG/customer-service:$TAG" -n "$NS"
          kubectl set image deploy/frontend-w10e1          frontend-container="$REG/frontend:$TAG" -n "$NS" || true

      - name: Wait for rollouts
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl rollout status deploy/product-service-w10e1   -n "$NS" --timeout=300s
          kubectl rollout status deploy/order-service-w10e1     -n "$NS" --timeout=300s
          kubectl rollout status deploy/customer-service-w10e1  -n "$NS" --timeout=300s
          kubectl rollout status deploy/frontend-w10e1          -n "$NS" --timeout=300s || true

      - name: Smoke test (internal curl)
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl run curlpod -n "$NS" --image=curlimages/curl:8.8.0 --restart=Never --rm -it -- \
            sh -lc '
              set -eux
              curl -fsS http://product-service-w10e1:8000/health
              curl -fsS http://order-service-w10e1:8001/health  || true
              curl -fsS http://customer-service-w10e1:8002/health || true
            '
