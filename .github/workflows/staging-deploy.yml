# .github/workflows/staging-deploy.yml 
# small change!!
name: CD - Staging (Create → Deploy → Test → Destroy)

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, reopened, synchronize, ready_for_review]

env:
  REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AKS_RG: deakinuni
  AKS_NAME: deakinstellak8s

concurrency:
  group: staging-pr-${{ github.event.number }}
  cancel-in-progress: true

jobs:
  deploy-staging:
    # PR must be from 'testing' in the same repo and into 'main'
    if: >
      github.event_name == 'pull_request' &&
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'testing' &&
      github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Gate: ensure a successful CI (push on 'testing') exists for this PR head SHA
      - name: Ensure CI success for PR head
        id: ensure-ci
        uses: actions/github-script@v7
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'testing',
              event: 'push',
              per_page: 100
            });
            const ok = runs.data.workflow_runs.find(r => r.head_sha === headSha && r.conclusion === 'success');
            if (!ok) core.setFailed(`No successful CI for head SHA ${headSha} on 'testing'.`);
            else core.info(`CI success: run #${ok.id}`);

      - name: Azure Login
        if: steps.ensure-ci.outcome == 'success'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        if: steps.ensure-ci.outcome == 'success'
        run: az aks get-credentials -g "$AKS_RG" -n "$AKS_NAME" --overwrite-existing

      # Use the same tag scheme as CI: testing-<short PR head SHA>
      - name: Compute image TAG from PR head
        if: steps.ensure-ci.outcome == 'success'
        id: meta
        run: |
          SHA="${{ github.event.pull_request.head.sha }}"
          echo "TAG=testing-${SHA::7}" >> "$GITHUB_OUTPUT"
          echo "REG=${{ env.REGISTRY }}" >> "$GITHUB_OUTPUT"

      - name: Show manifest tree (debug)
        if: steps.ensure-ci.outcome == 'success'
        run: |
          echo "Repo tree around k8s/:"
          ls -la
          echo "----- k8s/ -----"
          ls -la k8s || true

      - name: Create / ensure PR staging namespace
        if: steps.ensure-ci.outcome == 'success'
        id: ns
        run: |
          NS="stg-pr-${{ github.event.number }}"
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"
          echo "name=$NS" >> "$GITHUB_OUTPUT"

      # ── Apply manifests from root k8s/ ────────────────────────────────────────
      - name: Apply config & secrets
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f k8s/configmaps.yaml
          kubectl apply -n "$NS" -f k8s/secrets.yaml || true

      - name: Apply databases
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f k8s/product-db.yaml
          kubectl apply -n "$NS" -f k8s/order-db.yaml
          kubectl apply -n "$NS" -f k8s/customer-db.yaml

      - name: Wait for DB deployments
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl rollout status deploy/product-db-deployment-w10e1 -n "$NS" --timeout=300s || true
          kubectl rollout status deploy/order-db-deployment-w10e1   -n "$NS" --timeout=300s || true
          kubectl rollout status deploy/customer-db-deployment-w10e1          -n "$NS" --timeout=300s || true

      - name: Apply services
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl apply -n "$NS" -f k8s/product-service.yaml
          kubectl apply -n "$NS" -f k8s/order-service.yaml
          kubectl apply -n "$NS" -f k8s/customer-service.yaml
          kubectl apply -n "$NS" -f k8s/frontend.yaml || true

      - name: Set images to PR tag
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          REG="${{ steps.meta.outputs.REG }}"
          TAG="${{ steps.meta.outputs.TAG }}"
          kubectl set image deploy/product-service-w10e1  product-service-container="$REG/product-service:$TAG"   -n "$NS"
          kubectl set image deploy/order-service-w10e1    order-service-container="$REG/order-service:$TAG"       -n "$NS"
          kubectl set image deploy/customer-service-w10e1 customer-service-container="$REG/customer-service:$TAG" -n "$NS"
          kubectl set image deploy/frontend               frontend="$REG/frontend:$TAG"                           -n "$NS" || true
      
      - name: Wait for rollouts
        if: steps.ensure-ci.outcome == 'success'
        run: |
          NS="${{ steps.ns.outputs.name }}"
          kubectl rollout status deploy/product-service-w10e1   -n "$NS" --timeout=300s
          kubectl rollout status deploy/order-service-w10e1     -n "$NS" --timeout=300s
          kubectl rollout status deploy/customer-service-w10e1  -n "$NS" --timeout=300s
          kubectl rollout status deploy/frontend                -n "$NS" --timeout=300s || true

      - name: Smoke test (internal curl with retries)
        if: steps.ensure-ci.outcome == 'success'
        run: |
          set -eux
          NS="${{ steps.ns.outputs.name }}"

          svc_port () { kubectl get svc "$1" -n "$NS" -o jsonpath='{.spec.ports[0].port}'; }

          P_SVC=product-service-w10e1
          O_SVC=order-service-w10e1
          C_SVC=customer-service-w10e1
          F_SVC=frontend-w10e1

          P_PORT=$(svc_port $P_SVC)
          O_PORT=$(svc_port $O_SVC)
          C_PORT=$(svc_port $C_SVC)
          F_PORT=$(svc_port $F_SVC)

          kubectl run curlpod -n "$NS" --image=curlimages/curl:8.8.0 --restart=Never -- \
            sh -lc "
              set -eux
              for i in \$(seq 1 20); do
                curl -fsS http://$P_SVC:${P_PORT}/health && break || sleep 3
              done
              for i in \$(seq 1 10); do
                curl -fsS http://$O_SVC:${O_PORT}/health && break || sleep 3
              done || true
              for i in \$(seq 1 10); do
                curl -fsS http://$C_SVC:${C_PORT}/health && break || sleep 3
              done || true
              # frontend index
              for i in \$(seq 1 10); do
                curl -fsS -o /dev/null -w '%{http_code}\n' http://$F_SVC:${F_PORT}/ | grep -qE '^(200|301|302)$' && break || sleep 3
              done
            "
          kubectl delete pod -n "$NS" -l run=curlpod --ignore-not-found

      - name: Destroy staging environment (always)
        if: always()
        run: |
          kubectl delete namespace "${{ steps.ns.outputs.name }}" --wait=false